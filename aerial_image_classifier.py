# -*- coding: utf-8 -*-
"""aerial_image_classifier.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nbysQ948LgMOJYrOLVFUWCqDW1KXzXl7

#Aerial Image Classifier 

For classifying aerial images from the UC Merced Land Use dataset. 

http://weegee.vision.ucmerced.edu/datasets/landuse.html 

(Click the link to "Download the dataset.")

## Keras - Python Deep Learning Neural Network API

Blog: https://deeplizard.com/learn/playlist/PLZbbT5o_s2xrwRnXk_yCPtnqqo4_u2YGL
"""

# mount Google Drive 
# from google.colab import drive
# drive.mount('/content/drive')

# change directory 
import os
# os.chdir('/content/drive/MyDrive/BAN 676 - Deep Learning/individual project')

"""##Preprocessing

Image Preparation for Convolutional Neural Networks with TensorFlow's Keras API

Video: https://youtu.be/_L2uYfVV48I

Blog: https://deeplizard.com/learn/video/LhEMXbjGV_4
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Activation, Dense, Flatten, BatchNormalization, Conv2D, MaxPool2D
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.metrics import categorical_crossentropy
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import confusion_matrix
import itertools
#import os
#import shutil
#import random
#import glob
import matplotlib.pyplot as plt
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
# %matplotlib inline

# https://flaviocopes.com/python-list-files-folders/
img_dir = '/content/drive/MyDrive/BAN 676 - Deep Learning/individual project/source_data/UCMerced_LandUse/Images'
img_classes = os.listdir(img_dir)
print(img_classes) 
print(len(img_classes))

proj_dir = '/content/drive/MyDrive/BAN 676 - Deep Learning/individual project'
train_dir = proj_dir+'/train'
valid_dir = proj_dir+'/valid'
test_dir = proj_dir+'/test'

import cv2
img = cv2.imread('/content/drive/MyDrive/BAN 676 - Deep Learning/individual project/test/agricultural/agricultural90.tif')
print(img.shape)

train_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
    .flow_from_directory(directory=train_dir, target_size=(256,256), classes=img_classes, batch_size=10)

valid_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
    .flow_from_directory(directory=valid_dir, target_size=(256,256), classes=img_classes, batch_size=10)

test_batches = ImageDataGenerator(preprocessing_function=tf.keras.applications.vgg16.preprocess_input) \
    .flow_from_directory(directory=test_dir, target_size=(256,256), classes=img_classes, batch_size=10, shuffle=False)

def plot_images(images):
  figure, axes = plt.subplots(1, 10, figsize=(20,20))
  axes = axes.flatten() 
  for img, ax in zip(images, axes):
    ax.imshow(img)
    ax.axis('off')
  plt.tight_layout() 
  plt.show()

imgs, labels = next(train_batches)
plot_images(imgs)
print(labels) # <<< labels are one-hot encoded lists

"""##Build & Train Model

Build and Train a Convolutional Neural Network with TensorFlow's Keras API

Video: https://youtu.be/3V9YFPfgyAY

If you want to predict a single type, such as agricultural, then you can use a single node on the output layer, and set the loss function to binary crossentropy. See the video starting at 5:00. 

Video: https://youtu.be/3V9YFPfgyAY?t=300
"""

model = Sequential([
        Conv2D(filters=32, kernel_size=(3, 3), activation='relu', padding = 'same', 
               input_shape=(256,256,3)),
        MaxPool2D(pool_size=(2, 2), strides=2),
        # add a dropout layer 
        Conv2D(filters=64, kernel_size=(3, 3), activation='relu', padding = 'same'),
        MaxPool2D(pool_size=(2, 2), strides=2),
        # add more layers: Conv2D, MaxPooling2D, Dropout, etc. 
        Flatten(),
        Dense(units=len(img_classes), activation='softmax'),
])

model.summary()

'''
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy']) 
'''

#alternate compiler 
model.compile(optimizer=Adam(learning_rate=0.0001), 
              loss='categorical_crossentropy', 
              metrics=['accuracy'])

model.fit(x=train_batches,
          # generator contains labels, which are the values for y 
          steps_per_epoch=len(train_batches),
          validation_data=valid_batches,
          validation_steps=len(valid_batches),
          epochs=10, # add more epochs 
          verbose=2
)

# get max accuracy

"""##Make Predictions

Convolutional Neural Network Predictions with TensorFlow's Keras API

Video: https://youtu.be/e47ISlpYFok 

Blog: https://deeplizard.com/learn/video/bfQBPNDy5EM 
"""

test_imgs, test_labels = next(test_batches)
plot_images(test_imgs)
print(test_labels)

test_batches.classes

predictions = model.predict(x=test_batches, steps=len(test_batches), verbose=0)

np.round(predictions)

cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(classes))
    plt.xticks(tick_marks, classes, rotation=45)
    plt.yticks(tick_marks, classes)

    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    thresh = cm.max() / 2.
    for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
        plt.text(j, i, cm[i, j],
                 horizontalalignment="center",
                 color="white" if cm[i, j] > thresh else "black")

    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

test_batches.class_indices

print(img_classes)

plot_confusion_matrix(cm=cm, classes=img_classes, title='Confusion Matrix')

"""##Fine-Tuned VGG16 Model

Build A Fine-Tuned Neural Network With TensorFlow's Keras API

Video: https://youtu.be/3ou0KYtDlOI

Blog: https://deeplizard.com/learn/video/oDHpqu52soI
"""

# Download model - Internet connection needed
# vgg16_model = tf.keras.applications.vgg16.VGG16()
# Need to change input shape on VGG16 model 
# https://stackoverflow.com/questions/41903051/change-input-tensor-shape-for-vgg16-application
vgg16_model = tf.keras.applications.vgg16.VGG16(include_top=False, input_shape=(256,256,3))
vgg16_model.summary()

'''
def count_params(model):
    non_trainable_params = np.sum([np.prod(v.get_shape().as_list()) for v in model.non_trainable_weights])
    trainable_params = np.sum([np.prod(v.get_shape().as_list()) for v in model.trainable_weights])
    return {'non_trainable_params': non_trainable_params, 'trainable_params': trainable_params}
'''

'''
params = count_params(vgg16_model)
assert params['non_trainable_params'] == 0
assert params['trainable_params'] == 138357544
'''

type(vgg16_model)

model = Sequential()
for layer in vgg16_model.layers:
    model.add(layer) 
model.add(Flatten())
model.add(Dense(4096))
model.add(Dense(4096)) 
model.add(Dense(units=len(img_classes), activation='softmax'))
model.summary()

'''
params = count_params(model)
assert params['non_trainable_params'] == 0
assert params['trainable_params'] == 134260544
'''

# check summary to make sure params are already set to trainable 
'''
for layer in model.layers:
    layer.trainable = True 
'''

'''
params = count_params(model)
assert params['non_trainable_params'] == 134260544
assert params['trainable_params'] == 8194
'''

"""##Train the Fine-Tuned VGG16 Model

Train a Fine-Tuned Neural Network with TensorFlow's Keras API

Video: https://youtu.be/TguZ0WK0orQ

Blog: https://deeplizard.com/learn/video/INaX55V1zpY
"""

model.compile(optimizer=Adam(learning_rate=0.0001), 
              loss='categorical_crossentropy', 
              metrics=['accuracy'])

"""How to speed things up? """

model.fit(x=train_batches, validation_data=valid_batches, epochs=10, verbose=2)

# export model? 
model.save(proj_dir)

# assert model.history.history.get('accuracy')[-1] > 0.95

"""##Predict Using Fine-Tuned VGG16 Model


"""

predictions = model.predict(x=test_batches, steps= len(test_batches), verbose=0)

test_batches.classes

cm = confusion_matrix(y_true=test_batches.classes, y_pred=np.argmax(predictions, axis=-1))

test_batches.class_indices

print(img_classes)

plot_confusion_matrix(cm=cm, classes=img_classes, title='Confusion Matrix')
